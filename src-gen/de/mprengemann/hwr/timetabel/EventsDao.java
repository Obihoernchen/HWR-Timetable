package de.mprengemann.hwr.timetabel;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import de.greenrobot.dao.*;

import java.util.ArrayList;
import java.util.List;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.

/**
 * DAO for table EVENTS.
 */
public class EventsDao extends AbstractDao<Events, Long> {

  public static final String TABLENAME = "EVENTS";

  /**
   * Properties of entity Events.<br/>
   * Can be used for QueryBuilder and for referencing column names.
   */
  public static class Properties {
    public final static Property Id = new Property(0, Long.class, "id", true, "_id");
    public final static Property Uid = new Property(1, String.class, "uid", false, "UID");
    public final static Property Room = new Property(2, String.class, "room", false, "ROOM");
    public final static Property Lecturer = new Property(3, String.class, "lecturer", false, "LECTURER");
    public final static Property Type = new Property(4, String.class, "type", false, "TYPE");
    public final static Property FullDescription = new Property(5, String.class, "fullDescription", false, "FULL_DESCRIPTION");
    public final static Property Start = new Property(6, java.util.Date.class, "start", false, "START");
    public final static Property SubjectId = new Property(7, long.class, "subjectId", false, "SUBJECT_ID");
    public final static Property End = new Property(8, java.util.Date.class, "end", false, "END");
  }

  ;

  private DaoSession daoSession;

  private Query<Events> subjects_EventsQuery;

  public EventsDao(DaoConfig config) {
    super(config);
  }

  public EventsDao(DaoConfig config, DaoSession daoSession) {
    super(config, daoSession);
    this.daoSession = daoSession;
  }

  /**
   * Creates the underlying database table.
   */
  public static void createTable(SQLiteDatabase db, boolean ifNotExists) {
    String constraint = ifNotExists ? "IF NOT EXISTS " : "";
    db.execSQL("CREATE TABLE " + constraint + "'EVENTS' (" + //
        "'_id' INTEGER PRIMARY KEY ," + // 0: id
        "'UID' TEXT NOT NULL UNIQUE ," + // 1: uid
        "'ROOM' TEXT NOT NULL ," + // 2: room
        "'LECTURER' TEXT NOT NULL ," + // 3: lecturer
        "'TYPE' TEXT NOT NULL ," + // 4: type
        "'FULL_DESCRIPTION' TEXT," + // 5: fullDescription
        "'START' INTEGER," + // 6: start
        "'SUBJECT_ID' INTEGER NOT NULL ," + // 7: subjectId
        "'END' INTEGER);"); // 8: end
  }

  /**
   * Drops the underlying database table.
   */
  public static void dropTable(SQLiteDatabase db, boolean ifExists) {
    String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'EVENTS'";
    db.execSQL(sql);
  }

  /**
   * @inheritdoc
   */
  @Override
  protected void bindValues(SQLiteStatement stmt, Events entity) {
    stmt.clearBindings();

    Long id = entity.getId();
    if (id != null) {
      stmt.bindLong(1, id);
    }
    stmt.bindString(2, entity.getUid());
    stmt.bindString(3, entity.getRoom());
    stmt.bindString(4, entity.getLecturer());
    stmt.bindString(5, entity.getType());

    String fullDescription = entity.getFullDescription();
    if (fullDescription != null) {
      stmt.bindString(6, fullDescription);
    }

    java.util.Date start = entity.getStart();
    if (start != null) {
      stmt.bindLong(7, start.getTime());
    }
    stmt.bindLong(8, entity.getSubjectId());

    java.util.Date end = entity.getEnd();
    if (end != null) {
      stmt.bindLong(9, end.getTime());
    }
  }

  @Override
  protected void attachEntity(Events entity) {
    super.attachEntity(entity);
    entity.__setDaoSession(daoSession);
  }

  /**
   * @inheritdoc
   */
  @Override
  public Long readKey(Cursor cursor, int offset) {
    return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
  }

  /**
   * @inheritdoc
   */
  @Override
  public Events readEntity(Cursor cursor, int offset) {
    Events entity = new Events( //
        cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
        cursor.getString(offset + 1), // uid
        cursor.getString(offset + 2), // room
        cursor.getString(offset + 3), // lecturer
        cursor.getString(offset + 4), // type
        cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5), // fullDescription
        cursor.isNull(offset + 6) ? null : new java.util.Date(cursor.getLong(offset + 6)), // start
        cursor.getLong(offset + 7), // subjectId
        cursor.isNull(offset + 8) ? null : new java.util.Date(cursor.getLong(offset + 8)) // end
    );
    return entity;
  }

  /**
   * @inheritdoc
   */
  @Override
  public void readEntity(Cursor cursor, Events entity, int offset) {
    entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
    entity.setUid(cursor.getString(offset + 1));
    entity.setRoom(cursor.getString(offset + 2));
    entity.setLecturer(cursor.getString(offset + 3));
    entity.setType(cursor.getString(offset + 4));
    entity.setFullDescription(cursor.isNull(offset + 5) ? null : cursor.getString(offset + 5));
    entity.setStart(cursor.isNull(offset + 6) ? null : new java.util.Date(cursor.getLong(offset + 6)));
    entity.setSubjectId(cursor.getLong(offset + 7));
    entity.setEnd(cursor.isNull(offset + 8) ? null : new java.util.Date(cursor.getLong(offset + 8)));
  }

  /**
   * @inheritdoc
   */
  @Override
  protected Long updateKeyAfterInsert(Events entity, long rowId) {
    entity.setId(rowId);
    return rowId;
  }

  /**
   * @inheritdoc
   */
  @Override
  public Long getKey(Events entity) {
    if (entity != null) {
      return entity.getId();
    } else {
      return null;
    }
  }

  /**
   * @inheritdoc
   */
  @Override
  protected boolean isEntityUpdateable() {
    return true;
  }

  /**
   * Internal query to resolve the "events" to-many relationship of Subjects.
   */
  public synchronized List<Events> _querySubjects_Events(long subjectId) {
    if (subjects_EventsQuery == null) {
      QueryBuilder<Events> queryBuilder = queryBuilder();
      queryBuilder.where(Properties.SubjectId.eq(subjectId));
      queryBuilder.orderRaw("START ASC");
      subjects_EventsQuery = queryBuilder.build();
    } else {
      subjects_EventsQuery.setParameter(0, subjectId);
    }
    return subjects_EventsQuery.list();
  }

  private String selectDeep;

  protected String getSelectDeep() {
    if (selectDeep == null) {
      StringBuilder builder = new StringBuilder("SELECT ");
      SqlUtils.appendColumns(builder, "T", getAllColumns());
      builder.append(',');
      SqlUtils.appendColumns(builder, "T0", daoSession.getSubjectsDao().getAllColumns());
      builder.append(" FROM EVENTS T");
      builder.append(" LEFT JOIN SUBJECTS T0 ON T.'SUBJECT_ID'=T0.'_id'");
      builder.append(' ');
      selectDeep = builder.toString();
    }
    return selectDeep;
  }

  protected Events loadCurrentDeep(Cursor cursor, boolean lock) {
    Events entity = loadCurrent(cursor, 0, lock);
    int offset = getAllColumns().length;

    Subjects subjects = loadCurrentOther(daoSession.getSubjectsDao(), cursor, offset);
    if (subjects != null) {
      entity.setSubjects(subjects);
    }

    return entity;
  }

  public Events loadDeep(Long key) {
    assertSinglePk();
    if (key == null) {
      return null;
    }

    StringBuilder builder = new StringBuilder(getSelectDeep());
    builder.append("WHERE ");
    SqlUtils.appendColumnsEqValue(builder, "T", getPkColumns());
    String sql = builder.toString();

    String[] keyArray = new String[]{key.toString()};
    Cursor cursor = db.rawQuery(sql, keyArray);

    try {
      boolean available = cursor.moveToFirst();
      if (!available) {
        return null;
      } else if (!cursor.isLast()) {
        throw new IllegalStateException("Expected unique result, but count was " + cursor.getCount());
      }
      return loadCurrentDeep(cursor, true);
    } finally {
      cursor.close();
    }
  }

  /**
   * Reads all available rows from the given cursor and returns a list of new ImageTO objects.
   */
  public List<Events> loadAllDeepFromCursor(Cursor cursor) {
    int count = cursor.getCount();
    List<Events> list = new ArrayList<Events>(count);

    if (cursor.moveToFirst()) {
      if (identityScope != null) {
        identityScope.lock();
        identityScope.reserveRoom(count);
      }
      try {
        do {
          list.add(loadCurrentDeep(cursor, false));
        } while (cursor.moveToNext());
      } finally {
        if (identityScope != null) {
          identityScope.unlock();
        }
      }
    }
    return list;
  }

  protected List<Events> loadDeepAllAndCloseCursor(Cursor cursor) {
    try {
      return loadAllDeepFromCursor(cursor);
    } finally {
      cursor.close();
    }
  }


  /**
   * A raw-style query where you can pass any WHERE clause and arguments.
   */
  public List<Events> queryDeep(String where, String... selectionArg) {
    Cursor cursor = db.rawQuery(getSelectDeep() + where, selectionArg);
    return loadDeepAllAndCloseCursor(cursor);
  }

}
